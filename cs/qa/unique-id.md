# 分布式唯一 ID

## 特性

分布式场景下，经常需要全局唯一id标识。如消息唯一标识，事件唯一标识等等。

- **全局唯一**：必须保证生成的 ID 是全局性唯一的，这是分布式 ID 的基本要求；
- **有序性**：ID 需要按照某种规则有序，便于排序比较等操作；
- **可用性**：需要保证高并发下的可用性。除了对 ID 号码自身的要求，业务还对 ID 生成系统的可用性要求极高；
- **自主性**：分布式环境下不依赖中心认证即可自行生成 ID；
- **安全性**：不暴露系统和业务的信息。在一些业务场景下，会需要 ID 无规则或者不规则。


## 常用方案

### UUID (Universally Unique Identifier，即通用唯一标识码）

目的是生成某种形式的全局唯一 ID 来标识系统中的任一元素，尤其是在分布式环境下，UUID 可以不依赖中心认证即可自动生成全局唯一 ID。


<img src="https://cdn.ttgtmedia.com/rms/onlineimages/time_based_uuid_example-f.png" width="720px" heigth="600px"/>

细节可以阅读 [RFC4122 - A Universally Unique IDentifier (UUID) URN Namespace](https://datatracker.ietf.org/doc/html/rfc4122)


- **优点**：性能非常高，由于是本地生成，没有网络消耗
- **缺点**：不易于存储，UUID 太长，16 字节 128 位；信息不安全，基于时间的 UUID 可能会造成机器的 mac 地址泄露


### 数据库自增 ID

用现有数据库系统的功能实现；ID 号单调自增。

- **优点**：使用简单，满足基本业务需求，天然有序
- **缺点**：强依赖 DB，会由于数据库部署的一些特性而存在单点故障、数据一致性等问题

通常采用分段，预分配等手段进行优化，降低数据库异常带来的影响。


### Redis 生成 ID

依赖数据库生成存在性能瓶颈，可以使用redis的原子操作 INCR 和 INCRBY 来实现。


- **优点**：不依赖于数据库，使用灵活，性能也优于数据库
- **缺点**：引入新的组件 Redis，如果 Redis 出现单点故障问题，则会影响序号服务的可用性


### Snowflake 算法

雪花算法是一个开源的分布式 ID 生成算法，结果是一个 long 型的 ID。

snowflake 算法将 64bit 划分为多段，分开来标识机器、时间等信息，具体组成结构如下图：

<img src="https://github.com/cloudyan/snowflake/raw/master/docs/1.jpeg" />


1. 最高位，1bit，其值始终是0，没有实际作用。
2. 时间戳，41bit，精确到毫秒，总共可以容纳约69年的时间。
3. 工作机器id，10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。
4. 序列号，12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。

SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID？

同一毫秒的ID数量 = 1024 X 4096 = 4194304

java和python实现可以参阅 [分布式ID-雪花算法](https://wetts.github.io/2019/11/27/%E5%B7%A5%E7%A8%8B/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/)

网上很多开源实现，读者可以自行搜索。 


- **优点**：稳定性高，不依赖于第三方系统；使用灵活方便，可以根据业务需求特性调整算法中 bit 位；单机上 ID 单调自增，毫秒数在高位，整个 ID 是趋势递增的。
- **缺点**：强依赖机器时钟，时钟回拨会导致发号重复或者服务处于不可用状态；由于涉及到分布式环境下每个机器节点的时钟同步，ID 可能不是全局递增



### 工程实现

参考[分布式唯一 ID 生成方案浅谈](https://cloud.tencent.com/developer/article/2034844)。多数是对雪花算法的变种。加上**分段预分配**的手段进行优化。




