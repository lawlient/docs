# 数据库缓存一致性问题

> 所谓缓存，实际上就是用空间换时间，准确地说是用更高速的空间来换时间，从而整体上提升读的性能。


## 一致性挑战

以mysql数据库作为业务数据存储，Redis作为缓存提高系统读性能的场景为例。

最权威最全的数据在 MySQL 里。万一 Redis 数据没有得到及时的更新（例如数据库更新了没更新到 Redis），就出现了数据不一致。

所有使用缓存的场景都会存在如上的不一致场景。本质是副本数据未及时更新出现与主本数据的不一致。

由于redis缓存与mysql数据库之间没有事务保障，所以不可能完全实现redis与mysql之间的数据一致。

如果在redis与mysql之间的实现事务，则系统的性能会大打折扣，这样缓存的存在又失去了意义。


## 解决方案


从缓存的**更新时机**和**更新方式**上可以有**4**种方案。

更新数据库（前/后） x  缓存（删除/更新） = 4 种方式 


### 1. 更新数据库后更新缓存

```
updateMySQL(key, data);
updateRedis(key, data);
```

假设存在2个线程A和B，可能出现如下情况：

|  时间 |  线程 A（写请求）  |  线程 B（写请求） | 问题  |
|  :-:  |  :-                               |  :-                                                  | :-    |
|  T1   |   更新数据库为 99  |                   |       |
|  T2   |                    |  更新数据库为 98  |       |
|  T3   |                    |  更新缓存为 98    |       |
|  T4   |   更新缓存为 99    |                   |  此时缓存的值被显式更新为 99，但是实际上数据库的值已经是 98，数据不一致     |


### 2. 更新数据库前更新缓存

```
updateRedis(key, data);
updateMySQL(key, data);
```

这种方式的问题更大。因为不能保证数据库的更新一定成功。

|  时间 |  线程 A（写请求）      |  线程 B（写请求） | 问题  |
|  :-:  |  :-                               |  :-                                                  | :-    |
|  T1   |   更新缓存为 0         |                   |       |
|  T2   |                        |  更新缓存为 1     |       |
|  T3   |                        |  更新数据库为 1   |       |
|  T4   |   更新数据库数据为 0   |                   |  此时缓存的值被显式更新为 1，但是实际上数据库的值是 0，数据不一致 |


> 通常情况下，更新缓存再更新数据库是我们应该避免使用的一种手段。


### 3. 更新数据库前删除缓存


```
deleteRedis(key);//先删除缓存让缓存失效
updateMySQL();//再更新数据库
```

对于写写并发的情况下，上述操作没有问题，反正都是缓存失效。

可能出现如下情况：

|  时间 |  线程 A（写请求）                 |  线程 B（读请求）                                    | 问题  |
|  :-:  |  :-                               |  :-                                                  | :-    |
|  T1   |   删除缓存值                      |                                                      |       |
|  T2   |                                   |  1.读取缓存数据，缓存缺失，从数据库读取数据 100      |       |
|  T3   |   更新数据库中的数据 X 的值为 99  |  更新数据库为 1                                      |       |
|  T4   |                                   |  将数据 100 的值写入缓存                             |  此时缓存的值被显式更新为 1，但是实际上数据库的值是 0，数据不一致 |


针对如上场景，有种策略是“**延迟双删策略**”。即删除缓存前等待一段时间。

关键在于等待的时长如何设定。

- 如果时间太短，线程 A 第二次删除缓存的时间依旧早于线程 B 把脏数据写回缓存的时间，那么相当于做了无用功
- 如果设置得太长，那么在触发双删之前，新请求看到的都是脏数据



### 4. 更新数据库后删除缓存

```
updateMySQL();//再更新数据库
deleteRedis(key);//先删除缓存让缓存失效
```

|  时间 |  线程 A（写请求）                 |  线程 B（读请求）                                    |  线程 C（读请求）                              | 问题                                              |
|  :-:  |  :-                               |  :-                                                  |  :-                                            | :-                                                |
|  T1   |   更新主库 X = 99（原值 X = 100） |                                                      |                                                |                                                   |
|  T2   |                                   |                                                      |  读取数据，查询到缓存还有数据，返回 100        |  线程 C 实际上读取到了和数据库不一致的数据        |
|  T3   |   删除缓存                        |                                                      |                                                |                                                   |
|  T4   |                                   |  查询缓存，缓存缺失，查询数据库得到当前值 99         |                                                |                                                   |
|  T5   |                                   |  将 99 写入缓存                                      |                                                |                                                   |

大体上，采取先更新数据库再删除缓存的策略是没有问题的，仅在更新数据库成功到缓存删除之间的时间差内——[T2,T3)的窗口 ，可能会被别的线程读取到老值。


> 不一致性的问题无法在客观上完全消灭，因为我们无法保证数据库和缓存的操作是一个事务里的，而我们能做到的只是尽量缩短不一致的时间窗口。



## 总结

从一致性的角度来看，采取更新数据库后删除缓存值，是更为适合的策略。因为出现不一致的场景的条件更为苛刻，概率相比其他方案更低。

但是，删除缓存值意味着对应的 key 会失效，那么这时候读请求都会打到数据库。

如果这个数据的写操作非常频繁，就会导致缓存的作用变得非常小。而如果这时候某些 Key 还是非常大的热 key，就可能因为扛不住数据量而导致系统不可用。


以下策略可以应对绝大部分场景：

- **针对大部分读多写少场景，建议选择更新数据库后删除缓存的策略。**
- **针对读写相当或者写多读少的场景，建议选择更新数据库后更新缓存的策略。**


## 最终一致性如何保证？

### 缓存设置过期时间

由于缓存机制可能失败，如redis实例异常，为了防止缓存一直不一致，使用缓存时加上一个过期时间，借助缓存失效达到最终一致的目的。


### 如何减少缓存删除/更新的失败？

借助一个可靠的消息中间件就是一个不错的选择。

即更新数据库成功后，不是直接操作缓存，而是将数据操作写入消息队列，然后再消费消息更新缓存，失败时可以借助消息队列的 ATLEAST-ONCE 机制做重试。


### 如何处理复杂的多缓存场景？


```
updateMySQL();//更新数据库一条记录
deleteRedisKey1();//失效主页信息的缓存
updateRedisKey2();//更新打赏榜TOP10
deleteRedisKey3();//更新单日打赏榜TOP100
```

解决方案和上文提到的保证最终一致性的操作一样，就是把更新缓存的操作以 MQ 消息的方式发送出去，再由不同的系统进行订阅做聚合的操作。


### 通过订阅 MySQL binlog 的方式处理缓存

上述方法需要依赖消息中间件，另一种方式是订阅 MySQL 的 binlog，监听数据的真实变化情况以处理相关的缓存。




---

## 引用

- [万字图文讲透数据库缓存一致性问题](https://cloud.tencent.com/developer/article/2168718)
